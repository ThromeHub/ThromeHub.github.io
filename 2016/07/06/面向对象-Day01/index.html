<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaScript面向对象手札 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="内容主要包括-&amp;gt; 原型与原型链-&amp;gt; 词法作用域与作用域链-&amp;gt; 函数的四种调用模式-&amp;gt; 开始之前的语法基础测试:  ···    var datas = [   { name: &amp;apos;jim&amp;apos;, age: 19, gender: &amp;apos;男&amp;apos; },    { name: &amp;apos;jim&amp;apos;, age: 19, gender: &amp;apo">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript面向对象手札">
<meta property="og:url" content="http://yoursite.com/2016/07/06/面向对象-Day01/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="内容主要包括-&amp;gt; 原型与原型链-&amp;gt; 词法作用域与作用域链-&amp;gt; 函数的四种调用模式-&amp;gt; 开始之前的语法基础测试:  ···    var datas = [   { name: &amp;apos;jim&amp;apos;, age: 19, gender: &amp;apos;男&amp;apos; },    { name: &amp;apos;jim&amp;apos;, age: 19, gender: &amp;apo">
<meta property="og:updated_time" content="2017-07-30T07:27:04.889Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript面向对象手札">
<meta name="twitter:description" content="内容主要包括-&amp;gt; 原型与原型链-&amp;gt; 词法作用域与作用域链-&amp;gt; 函数的四种调用模式-&amp;gt; 开始之前的语法基础测试:  ···    var datas = [   { name: &amp;apos;jim&amp;apos;, age: 19, gender: &amp;apos;男&amp;apos; },    { name: &amp;apos;jim&amp;apos;, age: 19, gender: &amp;apo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-面向对象-Day01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/面向对象-Day01/" class="article-date">
  <time datetime="2016-07-06T10:51:33.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JavaScript面向对象手札
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="内容主要包括"><a href="#内容主要包括" class="headerlink" title="内容主要包括"></a>内容主要包括</h2><h4 id="gt-原型与原型链"><a href="#gt-原型与原型链" class="headerlink" title="-&gt; 原型与原型链"></a>-&gt; 原型与原型链</h4><h4 id="gt-词法作用域与作用域链"><a href="#gt-词法作用域与作用域链" class="headerlink" title="-&gt; 词法作用域与作用域链"></a>-&gt; 词法作用域与作用域链</h4><h4 id="gt-函数的四种调用模式"><a href="#gt-函数的四种调用模式" class="headerlink" title="-&gt; 函数的四种调用模式"></a>-&gt; 函数的四种调用模式</h4><h3 id="gt-开始之前的语法基础测试"><a href="#gt-开始之前的语法基础测试" class="headerlink" title="-&gt; 开始之前的语法基础测试:"></a>-&gt; 开始之前的语法基础测试:</h3><p>  ···<br>    var datas = [</p>
<pre><code>  { name: &apos;jim&apos;, age: 19, gender: &apos;男&apos; },

  { name: &apos;jim&apos;, age: 19, gender: &apos;男&apos; },

  { name: &apos;jim&apos;, age: 19, gender: &apos;男&apos; }

];
</code></pre><p>  ···</p>
<pre><code>要求以表格的形式将其展示出来( table )

诸君可以自己尝试并给自己打个分~
</code></pre><p>DOM 操作复习</p>
<p>  -&gt; 创建节点</p>
<pre><code>document.createElement        该方法用于创建元素节点对象

document.createTextNode       该方法用于创建文本节点对象

document.createAttribute      该方法用于创建属性节点对象
</code></pre><p>  -&gt; 将节点加到父容器中</p>
<pre><code>    &lt;div&gt;

          &lt;p class=&quot;c&quot;&gt;123&lt;/p&gt; 

    &lt;/div&gt;

        div 标签就是 p 标签的容器

        p 标签是文本 123 的容器，是属性 class=&quot;c&quot; 的容器



属性节点操作

    创建节点： var attr = document.createAttribute(&quot;属性名&quot;);

    节点赋值:  attr.nodeValue = &quot;属性值&quot;

    设置属性： node.setAttributeNode( attr )


文本节点操作

    创建节点： var text = document.createTextNode(&quot;文本内容&quot;);

    （节点赋值:  text.nodeValue = &quot;文本内容&quot;）

    设置属性： node.appendChild( text )
</code></pre><p>DOM-Core 和 HTML-DOM</p>
<p>  -&gt; 所有的属性操作中有两组方法</p>
<pre><code>getAttribute 和 setAttribute
</code></pre><p>  -&gt; JQuery中属性操作也有两组</p>
<pre><code>$( ).attr( )            可操作自定义属性

$( ).prop( )            不识别自定义属性
</code></pre><p>  -&gt; DOM 文档对象模型,</p>
<pre><code>    所有的 dom 结构的的文件都可以使用 dom 的思想进行处理.具有通用性, 

如果要具体的完成某件事情就需要复杂的代码. 我们称这组方法为 DOM-Core( 核心 DOM ).


 html 发展很快, 所以专门为 html 的操作制定了一套 api.

这类 api 快捷方便, 将这一类方法称为 HTML-DOM. 指的是专门用于 html 操作的 DOM.
</code></pre><p>DOM 要求</p>
<p>  1&gt; 基本的纯 DOM 方法要求掌握</p>
<p>  2&gt; 学会分析 DOM 树结构</p>
<p>  3&gt; 要求三级以上的亲属访问</p>
<pre><code>以当前元素为参考, 访问其 父节点, 子节点, 兄弟节点, 层级达三级

           parentNode

              |

previousNode —   node    —    nextNode

           |

        childNode
</code></pre><p>数据类型以及内存模型</p>
<p>  -&gt; 数据类型的分类( 术语 )</p>
<pre><code>    1&gt; 简单类型: 数字 number, 字符串 string, 布尔 boolean

    2&gt; 复合类型: 由简单类型或符合类型组合而成的数据类型

          1) 简单对象: 由简单类型直接组合而成

          2) 复杂对象: 由简单类型和复合类型组合而成的类型

          3) 函数

    3&gt; 空类型: null, undefined


简单类型的特点, 变量即数据本身. 即是说变量在内存中有一个固定的区域, 变量里面存储的就是该数据.

复合类型的特点, 变量无法直接存储数据, 我们的数据是单独存储在一个内存区域, 而变量只是存储的对应 &quot;地址&quot;( 引用 ).
</code></pre><p>  -&gt; 数据的内存模型</p>
<pre><code>-&gt; 主要讨论的是简单类型与复合类型

  -&gt; 简单类型变量即存储数据本身, 犹如在内存中有一个固定区域, 存储数据.

  -&gt; 复合类型, 变量中存储的是 &quot;地址&quot;, 因此数据单独存储在另外的内存中, 变量执行该数据.

-&gt; 由于简单类型存储的是数据本身, 因此又称其为值类型的. 而复合类型的变量存储的是真实数据的引用, 称其为引用类型.
</code></pre><p>值类型与引用类型在赋值与参数传递过程中的特征( 结论 )</p>
<pre><code>-&gt; 赋值的特征

  -&gt; 什么是赋值: 例如 代码 a = b, 含义是指将 b 变量表示的内存中存储的数据拷贝一份. 

      将拷贝的副本放到 a 这个变量所表示的内存中. 此时在内存中, 就出现了两个数据副本.


  -&gt; 对于值类型, 赋值表示的是将数据拷贝一份, 在内存中就会有两个相等的, 但是不同的数据.

      var num = 123;

      var num2;

      num2 = num;

      特征就是内存中有两个数据副本, 而且变量 num 与 num2 没有任何关系.


  -&gt; 对于引用, 赋值的含义不变, 是将一个变量中存储的数据拷贝一份放到另一个变量中.

      由于引用类型存储的并不是数据本身, 而是数据的地址, 因此拷贝的副本也是地址而非数据.

      所以在内存中仍然只有一个数据副本. 只是两个变量同时指向对象. 

      其表现出来的特征是利用任何一个变量修改数据, 另一个变量访问得到修改后的结果.


  -&gt; 注意:

      所有的操作是指利用对象指向操作属性, 而非直接给变量赋值. 如果是直接给变量赋值,

      就表示该变量重新进行了指向, 其规律就不一样了.



-&gt; 在函数参数传递的过程中的特征

  -&gt; 函数调用时的代码执行过程

      function func( num ) { // num = number

        console.log( num );

      }

      var number = 123;

      func( number );



      简单分析:

      1&gt; 赋值操作 number = 123; 

      2&gt; 准备调用函数

        1) 分配函数需要的内存

        2) 在分配内存的时候, 就已经对函数的参数进行了初始化

        3) 传参: 就是将调用函数处的参数拷贝一份, 将副本放到函数的参数所表示的内存中

      3&gt; 进入函数体执行函数内的代码

      4&gt; 函数执行结束, 释放函数占用内存, 回到函数调用的地方继续向下执行.
</code></pre><p>对象的动态特征</p>
<p>  -&gt; 所谓的动态特性是说如果一个对象没有某一个成员, 想要它提供该成员, 只需要选择赋值即可.</p>
<pre><code>var obj = {};

obj.name = &apos;jim&apos;;

var arr = [];

arr.push( 1 );
</code></pre><p>  -&gt; 技巧性的代码</p>
<pre><code>1&gt; in 运算符

  判断某一个属性是否在对象中. 语法:

    &apos;名字&apos; in 对象 -&gt; boolean

  如果对象中含有 这个名字 描述的属性, 就返回 true, 否则返回 false


2&gt; delete 运算符

  删除对象的某一个属性, 或数组的某一个元素, 或某一个未声明的全局变量.

  语法: delete 要删除的东西 -&gt; boolean

  表示的是 如果删除成功返回 true, 否则返回 false.



3&gt; 对象的属性可以使用 点语法 也可以使用 关联数组的方法

  obj.name 

  obj[ &apos;name&apos; ]

  obj[ name ]     // 此时 name 为变量, 方括号中为该变量的值
</code></pre><ol>
<li><p>深浅拷贝</p>
<p>-&gt; 拷贝: 就是将一个数据按照原来的样子再创建出一个来.</p>
<p>   我们在讨论深浅拷贝的时候, 都是在说对象的拷贝.</p>
</li>
</ol>
<pre><code>判断:

1&gt; 下面的代码有没有拷贝发生

  var obj1 = {};

  var obj2 = obj1;



2&gt; 下面的代码有没有发生拷贝

  var obj1 = {

    name: &apos;jim&apos;

  };

  var obj2 = {};

  obj2.name = obj1.name;



3&gt; 下面的代码有没有发生拷贝

  var obj1 = {

    name: &apos;jim&apos;,

    age: 19,

    gender: &apos;男&apos;

  };

  var obj2 = {};

  obj2.name = obj1.name;
</code></pre><p>  -&gt; 深浅拷贝</p>
<pre><code>  深浅拷贝专门针对于简单对象与复杂对象而言的.

  如果是拷贝, 而又是简单对象. 那么不存在深浅拷贝之分.

  如果拷贝的是复杂对象, 如果对象在内存中没有完全分离( 独立 )那就是浅拷贝. 

  如果完全分离就是 深拷贝.


-&gt; 简单对象的拷贝

  按照前面的实例, 要实现拷贝, 只需要先创建一个对象, 然后再将需要的数据一一加到这个对象中

  因此可以创建一个 clone 函数, 用于实现拷贝.



-&gt; 该方法是否可以用于复杂对象
</code></pre><p>  -&gt; 利用 JSON 对象实现深拷贝</p>
<pre><code>JSON.parse()        将 JSON 格式的字符串, 转换成对象

JSON.stringify()    将对象转换成 JSON 格式的字符串
</code></pre><p>递归练习:</p>
<pre><code>1. 等差数列: 1, 3, 5, 7, 9, ... 从 0 开始, 求 第 n 项( 不要使用公式, 使用递归完成 )

2. 兔子数列: 1, 1, 2, 3, 5, 8, ... 每一项都是前两项之和, 从 0 开始索引, 求 第 n 项

3. 利用递归实现 pow( n, m ), 表示的是 n 的 m 次方

4. 利用递归计算阶乘 n!, 所谓 n 的阶乘是指 n*(n-1)*(n-2)*...*1, 0! 是 1

5. 利用递归实现深拷贝, 实现 getElementsByClassName 方法
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/06/面向对象-Day01/" data-id="cj5qelv3q0001a4unkn8y3gp9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/07/19/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
    <a href="/2015/04/16/wode/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">wode</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/30/面向对象-Day05/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/07/19/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/07/06/面向对象-Day01/">JavaScript面向对象手札</a>
          </li>
        
          <li>
            <a href="/2015/04/16/wode/">wode</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>