<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="John Doe"><link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Canvas绘制基础手札 - Hexo</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">Hexo</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2016-02-25T10:46:07.000Z">February 25, 2016</time><h1 class="post__title"><a href="/2016/02/25/Canvas/">Canvas绘制基础手札</a></h1><div class="post__main echo"><h2 id="Canvas制图"><a href="#Canvas制图" class="headerlink" title="Canvas制图"></a>Canvas制图</h2><blockquote>
<p>Canvas 是 html5 中引入的用于展示图片的标签<br>Canvas 可以自定义展示的内容, 与绘制展示的内容</p>
</blockquote>
<p>.</p>
<h3 id="gt-应用领域"><a href="#gt-应用领域" class="headerlink" title="-&gt; 应用领域"></a>-&gt; 应用领域</h3><blockquote>
<p>canvas 就是一个用于展示图形的荧幕. 凡是可以看到的东西 canvas 都可以展示.<br>最典型的有广告 视频 二维动画游戏, 甚至是三维的视频游戏等.<br>canvas 就是基于浏览器的图形引擎.前期目标：完成数据的可视化</p>
</blockquote>
<p>.</p>
<h3 id="gt-基本使用"><a href="#gt-基本使用" class="headerlink" title="-&gt; 基本使用"></a>-&gt; 基本使用</h3><blockquote>
<ol>
<li><p>设置canvas标签</p>
</li>
<li><p>放置canvas 标签后, 如果浏览器支持就会为其开辟一个 300 * 150 像素的区域.</p>
</li>
<li><p>需要更改画布大小时, 使用 canvas 标签的属性 width 和 height.<br>不要使用css设置宽高.单位不同并且会拉伸有效像素点</p>
</li>
<li><p>canvas 提供一套绘图工具. 利用绘图工具可以进行画图.<br>语法：    canvas.getContext( “2d” )            //2d工具包<br>　　　　canvas.getContext( “webgl” )        //3d工具包</p>
</li>
<li><p>canvas 绘图与我们用笔绘图类似但又不完全相同<br>canvas 绘图采用先描点, 再连线的形式<br>context.moveTo( x, y )      落笔的方法<br>context.lineTo( x, y )      绘制到的方法( 绘制直线的 )<br>context.stroke()            描线的方法</p>
</li>
</ol>
</blockquote>
<p>注意: 我们在绘制的时候画笔画到哪里, 就会停到那里, 下次绘制的时候, </p>
<p>如果没有 moveTo 就会从这里继续开始绘制. 但是如果 beginPath 就需要重新moveTo. </p>
<p>同时在代码中如果没有moveTo, 首个lineTo即相当于moveTo.</p>
<p>6&gt; canvas 的坐标系与css3类似</p>
<p>x 轴水平向右为正.         —— x<br>|<br>y 轴垂直向下为正.        y</p>
<p>直角三角形和长方形.要求在等分的画布区域的中央</p>
<p>-&gt; 创建图层</p>
<p>context.beginPath();</p>
<p>调用该方法即会创建新的图层, 注意以前的图层将无法访问.如果未描线会丢失内容</p>
<p>线会变浅的原因</p>
<p>与canvas绘图的机制有关. 默认的 canvas 绘图采用的是线宽为 1 像素, 颜色为纯黑色.</p>
<p>实际上canvas在绘制水平或垂直线的时候, 如果绘制的线宽是 1, 实际上绘制了 2 个像素的线宽.</p>
<p>是在绘制的直线上下或左右两端各延展一个像素, 然后颜色降半.</p>
<p>-&gt; 路径闭合</p>
<p>线宽较大时, 会出现闭合的问题.</p>
<p>通常采用 ：context.closePath()</p>
<p>-&gt; 设置</p>
<p>设置线宽    context.lineWidth = Num</p>
<p>canvas绘制的原理上是同图层一次性描点连线. 所以设置线宽后需要重新开启新图层绘制（更换颜色同样适用）</p>
<p>如果在绘制直线的时候, 设置线宽为2px     需要在直线两端各延展1像素, 颜色不降半.</p>
<p>相近像素颜色不降半.相隔像素颜色降半</p>
<p>设置颜色    context.strokeStyle = CSS格式</p>
<p>设置连接方式    context.lineJoin</p>
<p>context.lineJoin = “round”    圆形尖端</p>
<p>context.lineJoin = “bevel”    切除尖端</p>
<p>context.lineJoin = “miter”    默认连接</p>
<p>设置线帽    context.lineCap</p>
<p>context.lineCap = “round”    圆形端点</p>
<p>context.lineCap = “square”    端点处多出单个矩形</p>
<p>注意</p>
<p>每次只允许在一个路径中绘制一个特征的图形</p>
<p>所谓的特征包含: 线宽, 颜色, 描线还是填充, 线帽, 线的拐点等特征</p>
<p>开启路径就好比在更换画笔, 需要新建画布 context.beginPath();</p>
<h2 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h2><p>绘制曲线</p>
<p>注意: 所谓的曲线实际上就是很多间距很小的直线连接起来构成曲线</p>
<p>实例：二次函数 y = x^2        x作用域 0-20</p>
<p>for ( var i = 0; i &lt;= 20; i++ ) {</p>
<p>var x = i;</p>
<p>var y = x * x;</p>
<p>}</p>
<p>1&gt; 图片变宽： </p>
<p>可将x的计算值缩小, 并将x的取值要扩大相应倍数</p>
<p>2&gt; 图片水平位移：        x 的取值范围需要变化.</p>
<p>右移：x 减去位移值</p>
<p>左移：x 加上位移值</p>
<p>3&gt; 图片竖直位移    </p>
<p>下移：y 加上位移值</p>
<p>上移：y 减去位移值</p>
<p>4&gt; 图像竖直拉伸：</p>
<p>y值与拉伸比例的乘积</p>
<p>练习: 绘制三角函数的图像</p>
<h2 id="绘制颜色"><a href="#绘制颜色" class="headerlink" title="绘制颜色"></a>绘制颜色</h2><p>修改绘制的颜色</p>
<p>语法： context.strokeStyle = CSS格式 </p>
<p>修改后的样式会被默认保留，修改后需要新建画布</p>
<p>练习: 渐变色块</p>
<p>绘制高为100, 宽为512的色块.</p>
<p>从左至右实现渐变： 蓝色( 0, 0, 255 ) —- 黑色 ( 0, 0, 0 ) —- 红色 ( 255, 0, 0 );</p>
<h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p>封闭填充</p>
<p>在绘制的时候, 我们可以连线一个封闭的区域. 使用 fill 方法将这个封闭的区域填充</p>
<p>填充颜色：     canvas.fillStyle = CSS格式 </p>
<p>注意事项：     如果绘制的不是闭合曲线, 那么fill会自动连接始末点并填充.</p>
<p>如果在填充的时候, 我们的绘制路径有交叉怎么办?</p>
<p>非零环绕原则:</p>
<p>canvas在绘制填充的时候只会填充闭合的区域. 如果没有闭合会</p>
<p>默认将开始与结束的点相连构成闭合. 一旦闭合可能会将闭合区域分割中很多部分.</p>
<p>此时判断这个部分要不要填充就可以使用 —- 非零环绕原则:</p>
<p>1&gt; 在这个区域内任意的选一点( 越简单, 越孤立越好 )</p>
<p>2&gt; 以选择的这个点为圆心, 绘制一条完全穿过图形的射线( 越简单越好 )</p>
<p>3&gt; 以这个点为圆心, 看穿过射线的线的方向( 以圆周方向 )</p>
<p>4&gt; 将顺时针记为 +1, 将逆时针记为 -1, 最后看所有穿过的线的对应数字求和. </p>
<p>5&gt; 如果求和的结果为 0 即不填充, 如果求和的结果 非零 0, 则填充.</p>
<h2 id="虚线"><a href="#虚线" class="headerlink" title="虚线"></a>虚线</h2><p>绘制虚线</p>
<p>设置虚线的时候就是在设置实线部分与空白部分的大小. 利用数组来描述其中的关系，技巧就在于如何利用该数组.</p>
<p>语法：context.setLineDash( 数组 )</p>
<p>虚线改回实线：用空数组即可</p>
<p>例如: </p>
<p>数组 [ 10, 10 ]     表示实线部分 10 像素 - 空白部分 10 像素</p>
<p>数组 [ 10, 5 ]     表示实线部分 10 像素 - 空白部分 5 像素.</p>
<p>如果给定的数组是奇数项, 那么实线空白部分轮询</p>
<p>再实线部分 5 像素, 空白部分 3 像素, </p>
<p>相当于 [ 10, 5, 3, 10, 5, 3 ]</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1&gt; 在坐标系中绘制 ( 10, 10 ) 这个点.</p>
<p>考虑到在坐标系中只有一个点. 那么这个点无论坐标是什么. 都应该绘制在正中心.</p>
<p>如果绘制的时候是 10 个点, 就应该考虑将 这个 10 个点按照规律平均的分配在坐标系中.</p>
<p>那么这 10 个点中, x 的最大值应该符合 坐标系中 x 对应的最大值. 十个点中, y 的最大值</p>
<p>应该符合坐标系 y 轴的最大取值.</p>
<p>2&gt; 绘制多点图</p>
<p>思路:</p>
<p>1) 随机数生成坐标</p>
<p>2) 求对应的 x,y 的最大值</p>
<p>3) 计算比例</p>
<p>4) 绘制点</p>
<p>5) 连线</p>
<hr>
<p>文本绘制</p>
<p>文字填充：    context.fillText( 文本内容, x坐标, y坐标 )</p>
<p>文字描边：    context.strokeText( 文本内容, x坐标, y坐标 )</p>
<p>测量长度：    context.measureText( 文本 )</p>
<p>字体样式：    context.font = CSS格式</p>
<p>水平对齐方式：     context.textalign</p>
<p>left        定位点在文字左边</p>
<p>center      定位点在文字中间</p>
<p>right       定位点在文字右边</p>
<p>垂直对齐方式:     context.textbaseline</p>
<p>top         定位点在上面</p>
<p>middle      定位点在中间</p>
<p>bottom      定位点在下面</p>
<p>练习：给定一个定位点, 在定位点的右方或左方绘制直线, 然后在直线上方绘制文字</p>
<p>绘制图片</p>
<p>context.drawImage( 图片对象, x, y )</p>
<p>context.drawImage( 图片对象, x, y, width, height )</p>
<p>context.drawImage( 图片对象, sx, sy, swidth, sheight, dx, dy, dwidth, dheight )</p>
<p>参数：图片对象可以通过实例化方式得到，html赋予图片的特权方式，非通用</p>
<p>var img = new Image；</p>
<p>img.src = “图片路径”</p>
<p>context.drawImage(img,x,y);</p>
<p>参数x y：绘制图片的横纵坐标</p>
<p>参数width height：绘制图片的长宽，设置单个值时另一个参数不会等比缩放</p>
<p>参数s-：图片源的坐标及长宽</p>
<p>参数d-：绘制图片的坐标及长宽</p>
<p>注意：    1&gt; 图片对象可以是img标签  canvas   video 等.</p>
<p>2&gt; 图片除支持本地资源外, 还支持网络资源</p>
<p>3&gt; 长宽比不保留，设置单个值时另一个参数不会等比缩放</p>
<p>4&gt; 使用绘图api的第三种形式, 可以利用精灵图绘制动画</p>
<p>变换( 坐标系变换 )</p>
<p>通过移动 旋转 拉伸坐标系, 利用新的坐标系来绘制一些复杂的图形.</p>
<p>坐标系平移：    context.translate( x, y )          </p>
<p>坐标系旋转：    context.rotate( Radian )           </p>
<p>坐标系拉伸：    context.scale( x, y )  默认为1</p>
<p>单位变换        用于初始化坐标系</p>
<p>context.translate(1,0,0,1,0,0)</p>
<p>变换可以叠加, 经历多次变换需要后初始化坐标系时使用</p>
<p>绘制设置存档</p>
<p>每次绘制图形时, 会绘制设置一些绘制样式( 线宽, 颜色, 虚线, 线帽 .. )</p>
<p>保存绘制样式：    context.save() </p>
<p>恢复绘制样式：    context.restore()</p>
<p>如此中间修改过的状态就不再影响其后的绘制了.此功能常常使用在绘制封装中.</p>
<p>封装绘图形状</p>
<p>考虑函数的名字:</p>
<p>矩形:   drawRect</p>
<p>正方形: drawSquare</p>
<p>圆形:   drawCircle</p>
<p>星形:   drawStar</p>
<p>考虑函数的参数</p>
<p>提供参数, 中心坐标, cx, cy</p>
<p>提供线宽, 线帽, 线连接</p>
<p>平移, 旋转, 缩放</p>
<p>描线, 填充</p>
<p>所以函数的参数以对象的形式存在</p>
<p>还提供一个参数, 是否使用角度制</p>
<p>实现一个正方形                    options为参数对象</p>
<p>function drawSquare( ctx, options ) {                考虑到完整性与语义化不建议直接使用ctx. </p>
<p>var cx = options.cx,                    绘制原点坐标</p>
<p>var cy = options.cy,</p>
<p>var width = options.width,                设置矩形宽度</p>
<p>var lineWidth = options.lineWidth || 1,            设置线宽</p>
<p>var lineDash = options.lineDash || [],            设置虚线</p>
<p>var lineJoin = options.lineJoin || “miter”,        设置链接方式</p>
<p>var lineCap = options.lineCap || “butt”,        设置线帽</p>
<p>var translate = options.translate || [ 0, 0 ],        设置坐标系平移</p>
<p>var rotate = options.rotate || 0,            设置坐标系旋转</p>
<p>var scale = options.scale || [ 1, 1 ],            设置坐标系拉伸</p>
<p>var isAngle = options.isAngle || false,            设置旋转参数是否为角度形式</p>
<p>var fill = options.fill || false,            设置绘图方式是否为填充</p>
<p>var stroke = options.stroke || false;             设置绘图方式是否为描线</p>
<p>// 开始绘制</p>
<p>ctx.save();                        保存绘图设置</p>
<p>ctx.beginPath();                    新建画布</p>
<p>// 初始化设置</p>
<p>ctx.lineWidth = lineWidth;</p>
<p>ctx.setLineDash( lineDash );</p>
<p>ctx.lineJoin = lineJoin;</p>
<p>ctx.lineCap = lineCap;</p>
<p>ctx.translate( translate[ 0 ], translate[ 1 ] );</p>
<p>ctx.rotate( isAngle ? aToR( rotate ) : rotate );</p>
<p>ctx.scale( scale[ 0 ], scale[ 1 ] );</p>
<p>fill &amp;&amp; ( ctx.fillStyle = fill );</p>
<p>stroke &amp;&amp; ( ctx.strokeStyle = stroke );</p>
<p>// 开始描点</p>
<p>ctx.rect( cx-width / 2, cy-width / 2, width, width );        绘制矩形</p>
<p>fill?ctx.fill():ctx.stroke();                    填充或描线</p>
<p>ctx.restore();                            恢复绘制设置</p>
<p>画布的保存</p>
<p>将图片转换成 base64 格式的字符串，为了方便在网络上传输</p>
<p>html5为a标签设置了下载功能</p>
<p>html部分：</p>
<canvas></canvas>

<p><a></a></p>
<p>script部分:</p>
<p>var cas = document.queryselector(“canvas”);</p>
<p>cas.width = 600;</p>
<p>cas.height = 400;</p>
<p>var ctx = cas.getContent(“2d”);</p>
<p>var img = new Image;</p>
<p>img.src = “图片路径”;</p>
<p>img.onload = function(){</p>
<p>ctx.drawImage(this,0,0,400,400);</p>
<p>}</p>
<p>document.queryselector(“a”).onclick = function(){</p>
<p>this.href = cas.toDataURL(“image/png”,1)        保存格式必须为png  压缩比                  </p>
<p>this.download = “保存文件名”            </p>
<p>}</p>
</div></header></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2017 John Doe</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>