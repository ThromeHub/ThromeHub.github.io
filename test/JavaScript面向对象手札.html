<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="John Doe"><link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>JavaScript面向对象手札 - Hexo</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0;"><header class="head"><h1 class="head-title u-fl"><a href="/">Hexo</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2016-07-06T10:38:13.000Z">July 6, 2016</time><h1 class="post__title"><a href="/test/JavaScript面向对象手札.html">JavaScript面向对象手札</a></h1><div class="post__main echo"><h3 id="Step-01-内容主要包括"><a href="#Step-01-内容主要包括" class="headerlink" title="Step-01 内容主要包括"></a>Step-01 内容主要包括</h3><blockquote>
<p>原型与原型链<br>词法作用域与作用域链<br>函数的四种调用模式</p>
</blockquote>
<p>.</p>
<h3 id="Step-00-开始之前的语法基础测试"><a href="#Step-00-开始之前的语法基础测试" class="headerlink" title="Step-00 开始之前的语法基础测试:"></a>Step-00 开始之前的语法基础测试:</h3><blockquote>
<p>   var datas = [<br>　　{ name: ‘jim’, age: 19, gender: ‘男’ },<br>　　{ name: ‘jim’, age: 19, gender: ‘男’ },<br>　　{ name: ‘jim’, age: 19, gender: ‘男’ }<br>    ];<br>要求以表格的形式将其展示出来( table ),诸君可以自己尝试并给自己打个分~</p>
</blockquote>
<p>·</p>
<h3 id="Stop-00-有必要进行的DOM-操作复习"><a href="#Stop-00-有必要进行的DOM-操作复习" class="headerlink" title="Stop-00 有必要进行的DOM 操作复习"></a>Stop-00 有必要进行的DOM 操作复习</h3><h4 id="gt-0-1-创建节点"><a href="#gt-0-1-创建节点" class="headerlink" title="-&gt; 0.1 创建节点"></a>-&gt; 0.1 创建节点</h4><blockquote>
<p>document.createElement　　　该方法用于创建元素节点对象<br>document.createTextNode　　  该方法用于创建文本节点对象<br>document.createAttribute　　　该方法用于创建属性节点对象</p>
</blockquote>
<p>.</p>
<h4 id="gt-0-2-将节点加到父容器中"><a href="#gt-0-2-将节点加到父容器中" class="headerlink" title="-&gt; 0.2 将节点加到父容器中"></a>-&gt; 0.2 将节点加到父容器中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line"> 　&lt;p class=&quot;c&quot;&gt;123&lt;/p&gt; </div><div class="line">&lt;/div&gt;  //div标签就是p标签的容器,p标签是文本123的容器,是属性class=&quot;c&quot;的容器</div></pre></td></tr></table></figure>
<p>.</p>
<h5 id="gt-0-3-属性节点操作"><a href="#gt-0-3-属性节点操作" class="headerlink" title="-&gt; 0.3 属性节点操作"></a>-&gt; 0.3 属性节点操作</h5><blockquote>
<p>创建节点：　　　　var attr = document.createAttribute(“属性名”);<br>节点赋值: 　　　　 attr.nodeValue = “属性值”<br>设置属性：　　　　node.setAttributeNode( attr )</p>
</blockquote>
<p>.</p>
<h5 id="gt-0-4-文本节点操作"><a href="#gt-0-4-文本节点操作" class="headerlink" title="-&gt; 0.4 文本节点操作"></a>-&gt; 0.4 文本节点操作</h5><blockquote>
<p>创建节点： 　　　var text = document.createTextNode(“文本内容”);<br>节点赋值:  　　　　text.nodeValue = “文本内容”<br>设置属性： 　　　node.appendChild( text )</p>
</blockquote>
<p>.</p>
<h5 id="gt-DOM-文档对象模型"><a href="#gt-DOM-文档对象模型" class="headerlink" title="-&gt; DOM 文档对象模型"></a>-&gt; DOM 文档对象模型</h5><p>　　所有的 dom 结构的的文件都可以使用 dom 的思想进行处理.具有通用性, 如果要具体的完成某件事情就需要复杂的代码.我们称这组方法为 DOM-Core( 核心 DOM ).html 发展很快, 所以专门为 html 的操作制定了一套 api.这类 api 快捷方便, 将这一类方法称为 HTML-DOM. 指的是专门用于 html 操作的 DOM.</p>
<p>．</p>
<h5 id="gt-DOM-要求"><a href="#gt-DOM-要求" class="headerlink" title="-&gt; DOM 要求"></a>-&gt; DOM 要求</h5><p>１.　基本的纯 DOM 方法要求掌握<br>２.　学会分析 DOM 树结构<br>３.　要求三级以上的亲属访问</p>
<p>　以当前元素为参考, 访问其 父节点, 子节点, 兄弟节点, 层级达三级</p>
<pre><code>           　parentNode
              　　|
previousNode —   node    —    nextNode
           　　　　|
        　　　childNode
</code></pre><p>．<br>．<br>．<br>.<br>.<br>.<br>.</p>
<h4 id="数据类型以及内存模型"><a href="#数据类型以及内存模型" class="headerlink" title="数据类型以及内存模型"></a>数据类型以及内存模型</h4><h5 id="gt-数据类型的分类-术语"><a href="#gt-数据类型的分类-术语" class="headerlink" title="-&gt; 数据类型的分类( 术语 )"></a>-&gt; 数据类型的分类( 术语 )</h5><p>　1&gt; 简单类型: 数字 number, 字符串 string, 布尔 boolean</p>
<p>　2&gt; 复合类型: 由简单类型或符合类型组合而成的数据类型<br>　　　1) 简单对象: 由简单类型直接组合而成<br>　　　2) 复杂对象: 由简单类型和复合类型组合而成的类型<br>　　　3) 函数</p>
<p>　3&gt; 空类型: null, undefined<br>简单类型的特点, 变量即数据本身. 即是说变量在内存中有一个固定的区域, 变量里面存储的就是该数据.<br>复合类型的特点, 变量无法直接存储数据, 我们的数据是单独存储在一个内存区域, 而变量只是存储的对应 “地址”( 引用 ).<br>.<br>.</p>
<h5 id="gt-数据的内存模型"><a href="#gt-数据的内存模型" class="headerlink" title="-&gt; 数据的内存模型"></a>-&gt; 数据的内存模型</h5><p>1&gt; 主要讨论的是简单类型与复合类型<br>　　-&gt; 简单类型变量即存储数据本身, 犹如在内存中有一个固定区域, 存储数据.<br>　　-&gt; 复合类型, 变量中存储的是 “地址”, 因此数据单独存储在另外的内存中, 变量执行该数据.</p>
<p>2&gt; 由于简单类型存储的是数据本身, 因此又称其为值类型的. 而复合类型的变量存储的是真实数据的引用, 称其为引用类型.<br>.<br>.</p>
<h5 id="值类型与引用类型在赋值与参数传递过程中的特征-结论"><a href="#值类型与引用类型在赋值与参数传递过程中的特征-结论" class="headerlink" title="值类型与引用类型在赋值与参数传递过程中的特征( 结论 )"></a>值类型与引用类型在赋值与参数传递过程中的特征( 结论 )</h5><h6 id="gt-赋值的特征"><a href="#gt-赋值的特征" class="headerlink" title="-&gt; 赋值的特征"></a>-&gt; 赋值的特征</h6><p>　　-&gt; 赋值特性: 例如 代码 a = b, 含义是指将 b 变量表示的内存中存储的数据拷贝一份<br>　　　　将拷贝的副本放到 a 这个变量所表示的内存中. 此时在内存中, 就出现了两个数据副本.<br>      ．</p>
<p>　　-&gt; 对于值类型, 赋值表示的是将数据拷贝一份, 在内存中就会有两个相等的, 但是不同的数据.<br>          <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var num = 123;</div><div class="line">var num2;</div><div class="line">num2 = num;</div><div class="line">　　　</div><div class="line">特征就是内存中有两个数据副本, 而且变量 num 与 num2 没有任何关系.</div></pre></td></tr></table></figure></p>
<p>　　-&gt; 对于引用, 赋值的含义不变, 是将一个变量中存储的数据拷贝一份放到另一个变量中.<br>　　　　由于引用类型存储的并不是数据本身, 而是数据的地址, 因此拷贝的副本也是地址而非数据.<br>　　　　所以在内存中仍然只有一个数据副本. 只是两个变量同时指向对象.<br>　　　　其表现出来的特征是利用任何一个变量修改数据, 另一个变量访问得到修改后的结果.<br><code>
</code></p>
<p>　　-&gt; 注意:<br>　　　　所有的操作是指利用对象指向操作属性, 而非直接给变量赋值. 如果是直接给变量赋值,<br>　　　　就表示该变量重新进行了指向, 其规律就不一样了.<br><code>
</code></p>
<p>　　-&gt; 在函数参数传递的过程中的特征<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">　　１&gt; 函数调用时的代码执行过程</div><div class="line"></div><div class="line">　　　　function func( num ) &#123; // num = number</div><div class="line">　　　　　　console.log( num );</div><div class="line">　　　　&#125;</div><div class="line">　　　　var number = 123;</div><div class="line">　　　　func( number );</div><div class="line"></div><div class="line">　　　　简单分析:</div><div class="line">　　　　1&gt; 赋值操作 number = 123; </div><div class="line">　　　　2&gt; 准备调用函数</div><div class="line">　　　　　1) 分配函数需要的内存</div><div class="line">　　　　　2) 在分配内存的时候, 就已经对函数的参数进行了初始化</div><div class="line">　　　　　3) 传参: 就是将调用函数处的参数拷贝一份, 将副本放到函数的参数所表示的内存中</div><div class="line"></div><div class="line">　　　　3&gt; 进入函数体执行函数内的代码</div><div class="line">　　　　4&gt; 函数执行结束, 释放函数占用内存, 回到函数调用的地方继续向下执行.</div></pre></td></tr></table></figure></p>
<p>对象的动态特征</p>
<p>  -&gt; 所谓的动态特性是说如果一个对象没有某一个成员, 想要它提供该成员, 只需要选择赋值即可.</p>
<pre><code>var obj = {};

obj.name = &apos;jim&apos;;

var arr = [];

arr.push( 1 );
</code></pre><p>  -&gt; 技巧性的代码</p>
<pre><code>1&gt; in 运算符

  判断某一个属性是否在对象中. 语法:

    &apos;名字&apos; in 对象 -&gt; boolean

  如果对象中含有 这个名字 描述的属性, 就返回 true, 否则返回 false


2&gt; delete 运算符

  删除对象的某一个属性, 或数组的某一个元素, 或某一个未声明的全局变量.

  语法: delete 要删除的东西 -&gt; boolean

  表示的是 如果删除成功返回 true, 否则返回 false.



3&gt; 对象的属性可以使用 点语法 也可以使用 关联数组的方法

  obj.name 

  obj[ &apos;name&apos; ]

  obj[ name ]     // 此时 name 为变量, 方括号中为该变量的值
</code></pre><ol>
<li><p>深浅拷贝</p>
<p>-&gt; 拷贝: 就是将一个数据按照原来的样子再创建出一个来.</p>
<p>   我们在讨论深浅拷贝的时候, 都是在说对象的拷贝.</p>
</li>
</ol>
<pre><code>判断:

1&gt; 下面的代码有没有拷贝发生

  var obj1 = {};

  var obj2 = obj1;



2&gt; 下面的代码有没有发生拷贝

  var obj1 = {

    name: &apos;jim&apos;

  };

  var obj2 = {};

  obj2.name = obj1.name;



3&gt; 下面的代码有没有发生拷贝

  var obj1 = {

    name: &apos;jim&apos;,

    age: 19,

    gender: &apos;男&apos;

  };

  var obj2 = {};

  obj2.name = obj1.name;
</code></pre><p>  -&gt; 深浅拷贝</p>
<pre><code>  深浅拷贝专门针对于简单对象与复杂对象而言的.

  如果是拷贝, 而又是简单对象. 那么不存在深浅拷贝之分.

  如果拷贝的是复杂对象, 如果对象在内存中没有完全分离( 独立 )那就是浅拷贝. 

  如果完全分离就是 深拷贝.


-&gt; 简单对象的拷贝

  按照前面的实例, 要实现拷贝, 只需要先创建一个对象, 然后再将需要的数据一一加到这个对象中

  因此可以创建一个 clone 函数, 用于实现拷贝.



-&gt; 该方法是否可以用于复杂对象
</code></pre><p>  -&gt; 利用 JSON 对象实现深拷贝</p>
<pre><code>JSON.parse()        将 JSON 格式的字符串, 转换成对象

JSON.stringify()    将对象转换成 JSON 格式的字符串
</code></pre><p>递归练习:</p>
<pre><code>1. 等差数列: 1, 3, 5, 7, 9, ... 从 0 开始, 求 第 n 项( 不要使用公式, 使用递归完成 )

2. 兔子数列: 1, 1, 2, 3, 5, 8, ... 每一项都是前两项之和, 从 0 开始索引, 求 第 n 项

3. 利用递归实现 pow( n, m ), 表示的是 n 的 m 次方

4. 利用递归计算阶乘 n!, 所谓 n 的阶乘是指 n*(n-1)*(n-2)*...*1, 0! 是 1

5. 利用递归实现深拷贝, 实现 getElementsByClassName 方法
</code></pre></div></header></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2017 John Doe</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>